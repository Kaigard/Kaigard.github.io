---
layout:       post
title:        "数字IC设计不完全指南"
author:       "Lei Dong, Kai Zhou"
header-img:   "img/post-bg-ASIC2.jpg"
header-mask:  0.4
catalog:      true 
tags:
    - ASIC
    - Guide
---

## 序-写在前面
该文档由东南大学20届学长整理创建。文档整理了数字ic设计全流程中涉及的相关知识以及秋招面试时重点考察的知识点。
文档整理的目的在于让新手icer在短时间内迅速成为一名知识面广，基本功扎实的数字ic工程师。让实验室同学从研一入学时起，就少走弯路，有目标有计划地学习数字ic知识。  
文档的整理建立在个人知识体系之上，只涉及数字ic设计中的基础知识，且难免会受限于经验的不足，眼界的狭隘而出现谬误，欢迎添加微信`dl961231`联系笔者对文档整理出现的谬误进行指正和讨论。  
本文的成文借鉴了大量前辈在网络上无私分享的知识总结，知识是无价的，但是正是这些前辈将他们的学习经验无私的分享出来，才为中国的ic行业注入了动力，增添了活力，拉高了行业的整体知识水平。在这里，我效仿各位前辈花了些许时间，对ic知识进行了一个总结归纳。希望本文档能够对后续进入本专业的同学有所助益，并且我希望凡是从本文档中获得助益的同学能够把无私的精神，分享的地精神传承下去，以包容进取的精神分享知识给周围人。越分享越幸运，知识烂在肚子里不会让你比别人更强，只会让人固步自封停滞不前！
另外，对于实验室本门的学弟学妹，我提出要求，希望学弟学妹每年对该文档进行一次改版、补充和再整理，希望你们能够站在前人的肩膀上拥有更广阔的视野，成就更高的高度。  
最后，我与所有进入数字ic领域的硅友们共勉：天道酬勤，大器晚成！

by 董雷  
2022/04/25
  
<br> 
把文档网页化更多是为了方便(文档传来传去太麻烦)，在学长原有准备的文档基础上，进行了扩展，文档还会持续更新。一切文档，包括教科书都未必是绝对正确的，遇到不确定的希望能够自己动手去试试，实践出真知。<br>
另：图片加载不出来或者网页加载慢，不是网站的问题，请自行科学上网。<br>
另另：已经开了评论功能，在网页最下面，应该大概也许也得科学上网才能用。<br>
（科学上网很有必要。。。）

by 周凯
2023/4/11

## 修订日志
| Rev. |  Date  |  Author  |  Description |  
| 1.0 | 2022/04/25 | 董雷 | 初版 |  
| 2.0 | 2023/04/11 | 周凯 | 文档网页化、增加手撕代码及随机用例。    |
（TMD，gitbook解析出来为什么是这个鬼样子？）
<br> 

# RTL篇
> 一切编程语言一旦脱离了编译器就仅仅是字符，所以任何理解不了的语法，动手去试试，编译器会给你答案。

## verilog语法
[Verilog Tutorial](https://www.chipverify.com/verilog/verilog-tutorial)  

### 阻塞与非阻塞
阻塞赋值：
```verilog
	always @(posedge clk or negedge rst_n) begin
		if(~rst_n) begin
			in <= 0;
			q1 <= 1;
			q2 <= 2;
			q3 <= 3;
		end else begin
			q1 = in;
			q2 = q1;
			q3 = q2;
		end
	end
```
在复位信号置高后的第一个时钟上升沿，in、q1、q2、q3全部变为0。

非阻塞赋值：
```verilog
	always @(posedge clk or negedge rst_n) begin
		if(~rst_n) begin
			in <= 0;
			q1 <= 1;
			q2 <= 2;
			q3 <= 3;
		end else begin
			q1 <= in;
			q2 <= q1;
			q3 <= q2;
		end
	end
```
在复位信号置高后的第一个时钟上升沿，in、q1为0，q2、q3均保持。

### VerilogHDL 可综合概述

1.Verilog HDL的基本功能之一是描述可综合的硬件电路。如何合理使用Verilog HDL描述高性能的可综合电路是本次课的主旨之一。相比C语言，最显著的区别在与HDL语言具备以下硬件设计的基本概念：
互连(connectivity)：wire型变量描述各个模块之间的端口与网线连接关系。
并发(concurrency): 可以有效地描述并行的硬件系统。
时间(time): 定义了绝对和相对的时间度量，可综合操作符具有物理延迟。
C语言是一种软件语言，所以并无上述硬件对象。  

2.硬件描述语言描述的电路，最终将通过逻辑综合工具、布局布线工具将其实现为芯片。但是，并不是verilog中所有的关键词都可以被综合为硬件电路。通常，有四个最常用的关键字被用来综合电路，分别是 `always`、`if-else`、`case`、`assign`，我们称之为可综合四大法宝。除此之外还有很多关键字。那么verilog 中众多的关键字有什么存在价值呢？这些不可综合的关键字都可以用于书写testbench。  
* 所有综合工具都支持的结构: `always`,&nbsp; `assign`,&nbsp; `begin`,&nbsp; `end`,&nbsp; `case`,&nbsp; `wire`,&nbsp; `tir`,&nbsp; `apply0`,&nbsp; `supply1`,&nbsp; `reg`,&nbsp; `integer`,&nbsp; `default`,&nbsp; `for`,&nbsp; `function`,&nbsp; `and`,&nbsp; `nand`,&nbsp; `or`,&nbsp; `nor`,&nbsp; `xor`,&nbsp; `xnor`,&nbsp; `buf`,&nbsp; `not`,&nbsp; `bufif0`,&nbsp; `bufif1`,&nbsp; `notif0`,&nbsp; `notif1`,&nbsp; `if`,&nbsp; `inout`,&nbsp; `input`,&nbsp; `instantitation`,&nbsp; `module`,&nbsp; `negedge`,&nbsp; `poesedge`,&nbsp; `operators`,&nbsp; `output`,&nbsp; `parameter`.
* 所有综合哦工具都不支持的结构: `time`,&nbsp; `defparam`,&nbsp; `$finish`,&nbsp; `fork`,&nbsp; `join`,&nbsp; `initial`,&nbsp; `delays`,&nbsp; `UDP`,&nbsp;, `wait`.
* 有些工具支持有些工具不支持的结构: `casex`,&nbsp; `casez`,&nbsp; `wand`,&nbsp; `triand`,&nbsp; `wor`,&nbsp; `trior`,&nbsp; `real`,&nbsp; `disable`,&nbsp; `forever`,&nbsp; `arrays`,&nbsp; `memories`,&nbsp; `repeat`,&nbsp; `task`,&nbsp; `while`.  

3.其中`for`语句被用来综合时，循环变量需要是常数，但是仍然不推荐使用`for`语句进行综合。  

4.`function`被用来综合时，一般是用来描述组合逻辑电路。  

#### 常见可综合语法与硬件的映射关系

1.`if-else` 通常会被逻辑综合其映射为多路选择器，输出结果由输入的条件决定。需根据设 计目标，小心设计：先“加”后“选”，先“选”后“加”。  

2.对于单 `if` 语句，逻辑综合工具会将其映射为<font color=red>无优先级</font>的判断结构。推荐初学者尽量使用 单 `if` 语句(`if...else if...else if...`) 描述多条件判断结构。
>此处zk认为单`if`语句也是有优先级的结构: [单击前往](https://blog.csdn.net/qq_26123429/article/details/119821509)

3.多 `if` 语句(`if...if...`），逻辑综合工具会将其映射为有优先级的判断结构。最后一级选择信号具有最 高优先级。具有优先级的多选结构会消耗组合逻辑优点与同步复位的无亚稳态产生的优点，在复位信号触发时，采用异步复位的即时触发；在复位信号释放时，采用同步信号f...`结构。设计方法： 最高优先级给最迟到达的关键信号。  

5.`case`是一种<font color=red>无优先级</font>
超前进位加法则可以通过逻辑复制，降低关 键信号的扇出，进而降低该信号的传播延迟，提高电路性能。 

4.如果我们发现电路中存在较多的公共单元，也可以通过资源共享的方式，减小面积。但是，一般来说，共享会导致性能下降，所以还要根据性能和面积进行取舍。 

5.在设计电路的时候，我们也可以根据数据的延迟，对这些资源进行顺序重排，降低传播延迟。如图所示，A 信号到来比较晚，我们就可以把它尽可能放到后面，隐藏其延迟。 

6.最后一个小建议。在代码书写过程中，尽可能使用 `always` 描述电路，`assign` 仅仅用来连线。少用?:这种形式，因为这种形式通常难以阅读，且多层嵌套后很难被综合器解释。 

7.所有的组合逻辑或锁存的 `always` 结构必须有敏感信号列表。这个敏感信号列表必须包含所有的输入信号。综合过程将产生一个取决于除敏感列表中所有其它值的结构，它将可能在行为仿真和门级仿真见产生潜在的失配。 

8.在综合过程中，每个 Verilog `always` 块敏感信号列表只能对应一个时钟。原因：这是将每一个过程限制在单一寄存器类型的要求，有利于逻辑综合和静态时序分析。  

9.不允许 `Wait` 声明和`# delay` 声明。`Wait` 声明语句，不论是清楚还是含糊，都不能用于可综合设计。从 RTL 级转换到 gate 级的综合工具一般都不支持 `Wait` 声明和`# delay`声明，为了有效的综合，这些语句应该避免。在不需要进行综合的行为模块中，如测试模块、表示行为的虚拟器件模块中可以使用。 

10.在时序电路中必须使用非阻塞赋值(`<=`)，组合逻辑电路必须使用阻塞赋值(`=`)，这个一定要注意，严格按这个要求写。 

11.分开异步逻辑与同步逻辑。避免综合和静态时序时碰到问题，简化约束和编码难度。

12.不可应用于非综合模块中（例如：总线模块，总线监视器或是模拟模块）除非他们被设计来综合仿真。 

13.分开控制逻辑和存储器，建议控制逻辑和存储器逻辑分成独立的模块。通常来说，存储器是用 memory compiler 生成的，其综合方式与 RTL代码不同，所以混在一起，不利用综合，不利于很方便地更换工艺库和平台。

<br>

### 可综合风格——在RTL书写中如何考虑延迟、面积等。

1.多路选择器构成的级联电路中，如果有个别信号到来的比较晚。那如何针对这个信号进行优化呢？尽可能把这个延迟较大的分支单独拿出来，放到离出口最近的选择器中。 

2.注意“先加后选”和“先选后加”两种方法对数据通道延迟的影响。先选后加，会使控制通道延迟变大。 

3.重点关注电路中的加法器、乘法器等较为复杂的逻辑单元，尽可能少使用。 

4.随着芯片工艺的进步和生产成本的降低，面积显得没有时序问题重要。但减少设计面积意味着成本降低、功耗降低，特別是对于 FPGA 的设计，直接决着 FPGA 的选型。一般综合过程中可以对面积进行优化，但在 RTL 编码中如果注意节约设计面积，往往可以达到事半功倍的效果。 

5.要减少设计的面积，首先应该学会估计设计使用资源的数量,如使用了多少个触发器、
加法器、乘法器。这个过程也可以借助一些工具完成。最终应该知道设计中哪些部分占
用了较大的面积，进而分析改进的方法。 

6.一般来说，触发器的数量由功能决定，很难减少，同时触发器的面积比较好估计，因此和时延问題一样，组合逻辑是改进的攻点。对应到 RTL 代码，就是各种操作符。因此，应该了解各种操作符会产生的电路。要知道，RTL 代码屮的一个`+`可能对应着一个 64位的加法器。以下这些操作符都可能产生较大 的组合逻辑，使用时应加以重视，如`+`、`-`、`×`、`÷`以及条件语句中 的比较运算。对于这些操作，首先应该判断其必要性，是否能用更简单的运算代替。  

7.如果，必须使用复杂的运算符，则应考虑是否可以资源共享。尽管电路逻辑综合工具也会在综合的过程中采用资源共享的方法进行优化，但是，综合器的策略是有限的，因此，在编写 RTL 的时候，应该尽量考虑共享，而不是把这项工作完全留给综合工具。  

8.除了操作符，多比特的信号也往往会占用较大的资源，因为使用这些信号的操作都是对所有的比特进行的，相当于成倍使用资源，因此，对这类信号的操作也应重视。  

9.除此之外，针对不同的设计，还有可能有各种各样的优化和改进的方法，但是，归结到一点，就是编写代码时，应对操作符有足够的重视，对有可能简化的地方尽量简化。逻辑简化往往在减少面积的同时也减少了延迟，因此，是值得花费一些时间的。  

10.对于功耗控制，主要措施包括如下：
* 门控时钟，门控时钟是电路设计最常用也是最有效的方法，在逻辑综合阶段可以让综合工具自行插入。
* 增加使能信号，使得部分电路只有在需要工作时才工作；
* 对芯片各个模块进行控制，在需要工作时才工作；
* 除了有用信号和时钟的翻转会消耗功耗，组合逻辑产生的毛刺也会大量消耗功耗。但是，毛刺在设计中无法避免，因此，只有尽量减少毛刺在电路中的传播，才可以减少功耗。即，在设计中，尽量把产生毛刺的电路放在传播路径的最后。另外，可以使用一些减少毛刺的技术。
* 对于有限状态机，可以通过低功耗编码（参考格雷码的特性4.3.2节）来减少电路的翻转。总的来说，使用这些技术时，应首先考虑全局的功耗控制；然后再 RTL 编码中，注意消耗功率较多的电路，如状态机、译码器、多路选择器等。最后，在综合中，使用门控时钟和其他减少功耗的优化技术。这里要注意下门控时钟和增加使能控制的区别。增加使能仅仅是使得电路的输出信号不再翻转，但是输入时钟每个周期还会继续翻转。而门控时钟则是直接关掉输入时钟，这种方法效果更好。  

11.如果可以在 RTL 编码 阶段考虑代码可能对布线产生的影响，就可能避免最后出现无法布通的情况。布线阶段，通常热点是一个影响布线质量的问题。我们在 RTL 阶段应该重视这种电路，及早发现可能在布线阶段产生的问题。如果设计的功能中确实需要采用大的 mux，可以通过其他方式改变他的结构。其基本的思路是将一个大的 mux 分解为多级较小的 mux。

<br>

### RTL设计指导原则

#### 概述 

RTL 级设计的评判标准很多，如时序性能、所占面积、可测试性、可重用性、功耗、时 钟域的分配、复位信号设计以及是否与所用 EDA 工具匹配等。如果设计目标是在 FPGA 或 CPLD 等可编程逻辑器件上实现，则还需考虑是否能发挥这些 PLD 的结构特点等。根据这些目标的组合和优先级设置，可以派生出很多不同的设计原则。这里仅讨论一般意义的指导 原则。通常来说，主要有三个指导原则：面积与速度互换、乒乓操作、流水线设计。 

我们先来讲面积与速度互换原则。这里的“面积”是指一个设计所消耗的目标器件(如FPGA 、CPLD 和 ASIC 等)的硬件资源数量或者 ASIC 芯片的面积。对于 FPGA 来说， 可以用所消耗的触发器 CFF) 和查找表(LUT)数量来衡量；对于 ASIC 来说，则可以用设 计的面积、门数等衡量。"速度"指设计在芯片上稳定运行时所能够达到的最高频率，这个频 率由设计的时序状况决定，与设计满足的时钟周期、PAD to PAD Time 、Clock Setup Time 、 Clock Hold Time 和 Clock-to-Output Delay 等众多时序特征量密切相关。 

面积和速度这两个指标贯穿于 RTL 设计的始终，是衡量设计质量的终极标准。这里讨 论一下设计中关于面积和速度的基本原则，即面积和速度的平衡与互换原则。作为矛盾的两个方面，面积和速度的地位是不一样的。相比之下，满足时序、工作频率的要求更重要一些，所以当两者发生冲突时，应采用速度优先的原则。 面积和速度的互换是 RTL 设计的一个重要思想。从理论上讲，一个设计如果时序余量 较大，所能跑的频率远远高于设计要求，那么就能通过功能模块复用减少整个设计所消耗的 芯片面积，也就是用速度的优势对换面积的节约。 

反之，如果一个设计的时序要求很高，普通方法达不到设计频率，那么一般可以通过将 数据流串并转换，井行复制多个操作模块，对整个设计采取"乒乓操作"和"串并转换"的思想 进行处理，在芯片输出模块处再对数据进行"井串转换"。
从宏观上看，整个芯片满足了处理速度的要求，这相当于用面积复制换取速度的提高。面积和速度互换的操作技巧很多，比如模块复用、"乒乓操作"、"串井转换"等，这些技巧需 要不断积累。 

#### 乒乓操作 
乒乓操作的最大特点是通过“输入数据选择单元”和“输出数据选择单元”按节拍、相互配 合的切换，将经过缓冲的数据流没有停顿地送到“数据流运算处理模块”进行运算与处理。把乒乓操作模块当做一个整体，站在这个模块的两端看数据，输入数据流和输出数据流都是连续不断的，没有任何停顿，因此非常适合对数据流进行流水线式处理。所以乒乓操作常常应用于流水线式算法，完成数据的无缝缓冲与处理。乒乓操作的第二个优点是可以节约缓冲区空间。另外，巧妙运用乒乓操作还可以达到**用低速模块处理高速数据流的效果**。  
![乒乓操作](https://github.com/Kaigard/Kaigard.github.io/raw/master/img/AIG_ASIC_img/Pipeline/Pipeline_Picture1.png)   

通过乒乓操作实现低速模块处理高速数据的实质是：通过 DPRAM 这种缓存单元实现了数据流的串并转换，并行用“数据预处理模块 1”和“数据预处理模块 2”处理分流的数据，是面积与速度互换原则的体现！  
![乒乓操作](https://github.com/Kaigard/Kaigard.github.io/raw/master/img/AIG_ASIC_img/Pipeline/Pipeline_Picture2.png)  

假设A输入数据速率是100m，第一个cycle将数据送入B1,第二个cycle将数据送入B2，第三个cycle将数据送入B1,依次反复送入B2\B1\B2。那么可以简单的得知，数据预处理模块的处理数据能力仅要求50m。  
时序图如下：   
![乒乓操作](https://github.com/Kaigard/Kaigard.github.io/raw/master/img/AIG_ASIC_img/Pipeline/Pipeline_Picture3.png)   

#### 流水线
流水线的参数设计中，系统时钟取决于最慢的流水线级的延时。 流水线分割点及级数的确定要考虑的因素包括：单元延迟时间及时钟频率的大小决定了数据通过速率，过多的级数不一定能产生最快的结果；太多寄存器的插入会导致芯片面积增加，布线困难，时钟偏差增加。  

流水线设计就是把规模较大、层次较多的组合逻辑电路分为几个级别，在每一级插入寄存器组暂存中间数据。例如K级的流水线就是从组合逻辑的输入到 输出恰好有K个寄存器组(分为K级，每一级都有一个 寄存器组)，上一级的输出是下一级的输入而又无反馈的电路。  

流水线技术主要应用在算术模块中。加法运算是最基本的DSP运算，减法、乘法、除法或 FI丌运算都可分解为加法运算。因此进行加法运算的加法器就成为实现DSP的最基本器件，所以研究如何提高 其运行速度很有必要。流水线技术在提高系统整体运行 速度方面绩效显著，因而采用流水线技术的加法器就成为继串联加法器、并行加法器之后在选择加法器时的首选。 
举个例子：如计算log(|a+b|)  
不插入流水线，一个clk内算出计算结果:  
![流水线](https://github.com/Kaigard/Kaigard.github.io/raw/master/img/AIG_ASIC_img/Pipeline/Pipeline_Picture4.png)  
电路的最小周期取决于: Tcq+Tadd+Tabs+Tlog+Tsu  
插入流水线，加法器组合逻辑后加寄存器、在求绝对值组合逻辑后加寄存器、在求对数组合逻辑后加寄存器。也就是3个时钟后才能得到数据的计算结果: 
![流水线](https://github.com/Kaigard/Kaigard.github.io/raw/master/img/AIG_ASIC_img/Pipeline/Pipeline_Picture5.png)  
电路的最小周期取决于: Tcq+max(Tadd+Tabs+Tlog)+Tsu  

> 一道题目:
> ![流水线](https://github.com/Kaigard/Kaigard.github.io/raw/master/img/AIG_ASIC_img/Pipeline/Pipeline_Picture6.png)  
> ![流水线](https://github.com/Kaigard/Kaigard.github.io/raw/master/img/AIG_ASIC_img/Pipeline/Pipeline_Picture7.png)
  
  
### Verilog面经  
#### `if-else`与`case`的区别
* `if-else`和`case`都是有优先级的，其中`case`可以通过`synthesis parallel_case`综合约束命令取消优先级；eg：  
```verilog
 case(sel) // synthesis parallel_case  
 ```  
* 在组合逻辑中若分支没写全则都会综合出锁存器，其中`case`可以通过`synthesis full_case`综合约束命令或`default`来避免，而`if-else`必须补全才可以避免。这里有一点要注意，`case`中对于不关心的情况可以随便赋什么具体值都可以，代价是会增加资源，所以在面积敏感的设计中一般在`default`中对不关心的情况赋值为x态，若用`synthesis full_case`则综合器会自动对没列出的情况赋值，并且它赋的值有利于减少逻辑资源的消耗。之所以赋具体值会导致资源增加，我们可以通过卡诺图化简来理解，对于并不关心的情况给x态在卡诺图化简时即可是0也可是1，这样肯定比我们给出固定值要得到更简单的表达式，所以资源会更少。     
* `case`是可综合的四态对比（0、1、x、z），`if-else`要么是二态对比,要么是不可综合的四态对比;此外`casez`是忽略高阻态z进行比较，`casex`同时忽略x、z进行比较。   
* 在FPGA开发时，在RTL view中看到if-else具有明显优先级而case却是并行的，所以很多人便认为case是并行的，if-else才是具有优先级的，其实这个结论是错的。这是因为RTLview显示的是编译后的结果，显示的图形都是调用标准单元，跟工艺库、FPGA 类型都没有关系。更准确的应该看 TechnologyMap view，此时显示的是已经编译并映射到对应的 FPGA 器件中，是布局布线后的结果。由于现在的综合工具比之前的强大很多，所以会自动进行优化，即使你用if-else写出带有优先级的电路，综合工具在分析后认为并行更合理也会综合成并行的电路，因此这两种语法在强大的综合工具面前只是2种不同的表达方式，综合结果很可能是一样的，就看你更喜欢使用哪种描述方式。    
* 通常`if-else`结构速度较慢，但占用的面积小，如果对速度没有要求但对面积有较高要求，则可用`if-else`结构完成编解码。`case`结构速度较快，但占用面积较大，所以用`case`语句实现对速度要求较高的编解码电路。嵌套的`if`语句如果使用不当，就会导致设计的更大延时，为了避免较大的路径延迟，最好不要使用特别长的嵌套`if`结构。如想利用`if`语句来实现那些对延时要求苛刻的路径时，应将最高优先级给最迟到达的关键信号。 
* case的比较  
```verilog
//综合后是并行的     		//综合后是带优先级的  	//综合后是并行的
case(sel[2:0])         		case(1)               		case(1)//synthesis parallel_case
3'd1:addr = 3'd0;      		sel[0]:addr = 3'd0;   		sel[0]:addr = 3'd0;
3'd2:addr = 3'd1;  			sel[1]:addr = 3'd1;   		sel[1]:addr = 3'd1;
3'd4:addr = 3'd2;  			sel[2]:addr = 3'd2;   		sel[2]:addr = 3'd2;
default:addr=x;    			default:addr=x;       		default:addr=x;
endcase            		   endcase               	   endcase
```  
#### `if-else`中的优先级  
在Verilog中，我们经常会用到`if...else`这种结构，综合出来的电路是具有优先级的。  
当全部使用`if`判断时，优先级从上到下(往下优先级越高)，如果在某一级（设为第n级）的`if`下加入了`else`，则当第n级不成立时，则执行`else`中的语句，前面的n-1级中的判断即使成立也将无效。  
当使用`if`/`else if`判断时，第一级优先级最高，当第n级结果成立后，后面的n+1,n+2...等即使成立也不再进行判断。  
最高优先级的电路靠近电路的输出，输入到输出的延时较短；最低优先级的电路远离输出端，输入到输出的延时较长。  

#### 使用与非门搭建二选一选择器  
![流水线](https://github.com/Kaigard/Kaigard.github.io/raw/master/img/AIG_ASIC_img/Pipeline/Pipeline_Picture8.png)

#### 只使用二选一选择器搭建与非门  
和上面的方法一样，先画真值表。然后使用3元操作符描述出选择器结构。不论是与非门还是异或门或者是同或门都是一样的方法，并且，最简资源都是2个选择器就可以搭。  
```Y = A ? (B ? 1 : 0) : (B ? 0 : 1)```  
如果是最简呢？  
```Y = A ? (B ? 1 : 0) : 1 ```   
只需要两个选择器即可。  
![流水线](https://github.com/Kaigard/Kaigard.github.io/raw/master/img/AIG_ASIC_img/Pipeline/Pipeline_Picture9.png)


<br>  

## System Verilog
### SV基本语法
#### 各种各样的数组
* 合并数组：存储方式连续，中间没用闲置空间。表示方法：数组大小和位宽必需放在变量名前制定，数组大小必需为降序。<br>
如：```bit [3:0] [7:0] bytes; ```
* 非合并数组：存储的数据都是相互独立的。<br>
表示方法：<br>
```bit [7:0] bytes [3:0]; ```或  ``` bit bytes[7:0] [3:0]; ```
* 动态数组：随机事务不确定大小。<br>
定义方法：```int dyn[];``` <br>
在使用时需要使用`new[n]`来动态分配空间。如：```dyn = new[5]; ```<br> 
动态空间使用结束后，需要释放空间：``` dyn.delete();``` <br>动态空间的释放是很必要的，在硬件编程思维中没用内存占用这个概念，但是在软件编程中，内存管理好坏直接决定所写程序性能，用完的动态空间随手释放，是个很好的习惯。<br>
动态数组内建方法：<br>
```num = dyn.size       //获取数组大小```
* 关联数组：可以存放稀疏矩阵中的值，类似于链表，关联数组有利于使用零散的存储空间，关联数组存储数据并不是连续的存储空间。<br>
关联数组声明方式：```data_type array_name[index_type];```, 例如：```int array[string];```，其中`int`为关联数组存储数据的类型为`int`型数据，数组的索引为字符串索引。<br>
关联数组的索引可以为以下几种：
  1. 通配符索引：任意数据类型进行索引：```int array_name [*];```
  2. 字符串索引：```int array_name[string];```
  3. 类索引：```int array_name [some_Class];```
  4. integer（或int）索引：```int array_name[integer];```
  5. 有符号的压缩数组索引：```typedef bit signed [4:1] Nibble; int array_name[Nibble];```
  6. 无符号的压缩数组索引：```typedef bit [4:1] Nibble; int array_name [Nibble];```
  7. 其它用户定义类型索引：```typedef struct { real R; int I[*]; } Unpkt; int array_name [Unpkt];``` <br>

    实际上，关联数组实现了一个所声明类型的元素的查找表。用作索引的数据类型作为查找表的查找键值，并强制了一种顺序。例如：
    ``` system verilog
    integer i_array[*];   // 整数关联数组（未指定索引）
    bit [20:0] array_b[string];  // 21位向量的关联数组，使用字符串类型作为索引
    event ev_array[myClass];   // 事件类型的关联数组，使用类myClass索引
    ```
    关联数组的一些方法：
    ``` system verilog
    num()  //返回数组长度
    delete()  //删除指定元素或者所有元素
    exists()  //检查是否元素存在，存在返回1，否则返回0
    first()  //将指定的索引变量赋值为数组第一个索引的值
    last()  //将指定的索引变量赋值为数组最后一个索引的值  
    next()  //索引变量被赋值为下一个条目的索引
    prev()  //索引变量被赋值为上一个条目的索引
    ```
    关联数组注意事项：
    简单的for循环不能遍历关联数组，需要使用foreach遍历数组，还可以使用内建的first()和next()函数。<br>
    读取不存在的关联数组元素，4值逻辑返回x，2值逻辑返回0。<br>
    关联数组的索引可以是多种数据类型：string、int，甚至是class以及用户自定义的数据类型。<br>
    关联数组举例 ：
    ``` system verilog
    initial begin
      bit [63:0] assoc[int],idx =1;
      // Initialize widely scatteredvalues
      repeat (64) begin
        assoc[idx] =idx;
        idx = idx << 1;
      end
      // Step through all index values withforeach
      foreach (assoc[i])
      $display("assoc[%h]= %h", i, assoc[i]);
      // Step through all index values withfunctions
      if (assoc.first(idx))
        begin // Get first index
          do
            $display("assoc[%h]=%h",idx, assoc[idx]);
          while (assoc.next(idx)); // Get next index
        end
    // Find and delete the first element
      assoc.first(idx);
      assoc.delete(idx);
      $display("The array now has %0delements", assoc.num);
    end
    ```
* 队列：system verilog中的队列概念类似于数据结构中的队列、堆栈、列表的结合，在进行对序列的测试时，使用队列对数据进行暂存是非常方便的。
定义方式：```int data_q[$];``` <br>
队列所提供的方法：
  ``` system verilog
  queue_name.size                  //返回queue的大小
  queue_name.insert(index,item)    //在index索引处插入item元素
  queue_name.delete(index)         //刪掉某元素或整个queue
  queue_name.pop_front()           //去除第一个元素(队首）
  queue_name.pop_back()            //去除最后一个元素（队尾）
  queue_name.push_front()          //插入元素到queue(0)（队首）
  queue_name.push_back()           //插入元素到queue($)（队尾）
  ```
  队列举例：  
  ``` system verilog
  int j = 1,
  q2[$]={3,4}, // Queue literals do not use‘
  q[$]={0,2,5}; // {0,2,5}
  initial begin
    q.insert(1, j); // {0,1,2,5} Insert 1before 2
    q = {q[0:2],3,4,q[3]}; // {0,1,2,3,4,5}Insert queue in q
      q.delete(1); // {0,2,3,4,5} Delete elem.#1
  // These operations are fast
    q.push_front(6);// {6,0,2,3,4,5} Insert at front
    j = q.pop_back;// {6,0,2,3,4} j = 5
    q.push_back(8);// {6,0,2,3,4,8} Insert at back
    j = q.pop_front;// {0,2,3,4,8} j = 6
    foreach (q[i])
      $display(q[i]);// Print entire queue
    q.delete(); // {} Delete entirequeue
  end
  ```
#### 常量
* 文本宏<br>
文本宏的作用域为全局，使用文本宏可以减少修改时带来的麻烦，但是文本宏会引起冲突。
* parameter <br>
作用域为module，可以module外部被更改，使得module更加泛式。
* localparam <br>
sv所特有，不可在module外部更改，常用作状态机状态定义。当编写RTL时用到该关键字，DC必需以sverilog模式读入代码，否则会报错！
* 枚举 <br>
可综合，由EDA自动分配数值，在定义状态机状态时更加快速高效。


#### function与task小讨论
##### function
基础定义：
``` system verilog

```

<br>

## 同步电路  

### 同步电路的相关概念
同步电路的定义：同步电路即电路中所有受时钟控制的单元，全部由一个统一的全局时钟控制。

同步电路设计的优点：
* 在同步设计中，EDA工具可以保证电路系统的时序收敛，有效避免了电路设计中竞争冒险现象。
* 由于触发器只有在时钟边缘才改变取值，很大限度地减少了整个电路受毛刺和噪声影响的可能。
* EDA工具的支持，可以方便的进行STA检查。  

同步电路设计的缺点:
* 时钟偏斜（Clock Skew） 由电路中不同寄存器距离时钟源点的距离不同所产生，也就是时钟到达不同路径的时间不一致，相差的时间就是时钟偏斜。
* 时钟抖动（Clock Jitter）
* 时钟树综合，需要加入大量的延迟单元平衡以上影响，使得电路的面积和功耗大大增加。  

### 异步电路的相关概念
异步电路定义：电路中没有一个全局的或局部的控制时钟，电路中的数据传输可以在任何时候发生。
> **注意!** 如果不同时钟是从同一个PLL分频出来的，那么这些不同时钟的频率和相位互相之间是可控和明确的。这些不同时钟仍然属于同步时钟。

![同步电路](https://github.com/Kaigard/Kaigard.github.io/raw/master/img/AIG_ASIC_img/Synchronization/Synchronization_Picture1.png)

异步电路的优点：
* 模块化特性突出
* 对信号的延迟不敏感
* 没有时钟偏斜问题
* 有潜在的高性能特性
* 好的电磁兼容性
* 具有低功耗的特性  

异步电路的缺点：
* 设计复杂
* 缺少相应的EDA工具的支持
* 在大规模集成电路设计中应该避免采用异步电路设计 

由于EDA工具的广泛支持，采用同步电路设计的方法是目前ASIC和SOC设计的基本要求，但是通常大规模ASIC和SOC芯片都采用了全局异步、局部同步的方法。因此必须注意异步信号与同步电路的交互问题。
>实际上，成熟的CPU(Cortex-M0、Cortex-M3等)均采用异步复位电路，因为在CPU此类设计中可以采用大量手段规避缺点。

### 异步复位同步释放

#### 同步复位

优点：
* 有利于仿真器的仿真。
* 可以使所设计的系统成为100%的同步时序电路，这大大有利于时序分析，而且综合出来的fmax一般较高。
* 因为它只有在时钟有效电平到来时才有效，所有可以滤除高于时钟频率的毛刺。  

缺点：
* 复位及时性较差，复位有效时间要求大于一个时钟周期。
* 由于常见的基础单元为异步复位的DFF,若要配置成同步复位的话，需要加一些额外的组合逻辑，当巨量的复位需求时，硬件资源的消耗不可忽视。  

#### 异步复位  

异步复位指，复位信号与时钟信号没有特定的相位关系，注意这里是复位信号的触发和释放与时钟信号均无相位关系。从复位信号的下降沿开始，复位信号即处于有效阶段，后续模块会被立即复位。  

优点：复位及时性强，跳变时刻即触发复位，对复位持续时间无特殊要求。  
缺点：由于异步复位信号缺少与时钟的约束，其释放有可能落入恢复和去除时间（类似同步电路中的建立保持时间）。容易为电路带来亚稳态的风险。 

#### 异步触发同步释放复位及Verilog设计  

异步触发同步释放结合了异步的立即复位的优点与同步复位的无亚稳态产生的优点，在复位信号触发时，采用异步复位的即时触发；在复位信号释放时，采用同步信号的上升沿释放。    
构建方法：使用两级触发器级联，异步复位，同步释放即可。

### 状态机

#### 状态机的基本概念  

>状态机体现了设计师的设计功底，是电路时序逻辑设计的重要组成部分。  

状态机的本质：对具有逻辑顺序和时序规律的一种描述方法。  
基本要素： 状态 + 输入 + 输出 
状态机的分类：米勒型、摩尔型，其中米勒型状态机的输出是输入的函数，而摩尔型状态机的输出与输入无关。  

#### 如何写好状态机  

使用HDL语言描述状态机有一定的灵活性，但不能天马行空，有一定的规律可行。
状态机一般可以分为一段式状态机、二段式状态机、三段式状态机。

#### 二段式状态机与三段式状态机  

二段式：状态切换用时序逻辑，次态判断和信号输出用组合逻辑。  
三段式：状态切换用时序逻辑，次态判断用组合逻辑，信号输出用时序逻辑。  

### 同步FIFO  

[点击跳转至代码实现](#同步FIFO)  

<br>

## 跨时钟电路设计（CDC）

跨时钟电路主要分为这几种：双锁存器法、单bit信号跨时钟域、多bit指示信号跨时钟域、多bit数据跨时钟传输。其中单bit信号的跨时钟域电路又分为漫时钟到快时钟，快时钟到漫时钟。

### 亚稳态

亚稳态是指触发器无法在某个规定时间段内达到一个可确认的状态。
当一个触发器进入亚稳态时，既无法预测该单元的输出电平，也无法预测何时输出才能稳定在某个正确的电平上。
在这个期间，触发器输出一些中间级电平，或者可能处于振荡状态，并且这种无用的输出电平可以沿信号通道上的各个触发器级联式传播下去。
亚稳态不能从根本上消除，但可以通过采取一定的措施使其对电路造成的影响降低。

#### 计算公式
故障间隔平均时间：
![跨时钟电路设计](https://github.com/Kaigard/Kaigard.github.io/raw/master/img/AIG_ASIC_img/CDC/CDC_Picture1.png)

>tmet -- 寄存器从时钟上升沿出发后的时序裕量时间  
=采样时钟周期时间 - 输出信号正常的Tcq时间 - 数据到达下一级寄存器的输入端口的其他延时时间Tdata(组合逻辑时延) - 下一级寄存器Tsu时间 - 时钟网络延时时间Tclk2 - Tclk1  
fclk - 接受时钟域的时钟频率  
fdata - 数据的变化频率  
C1、C2 - 与器件有关的参数 （固定值）
  
![跨时钟电路设计](https://github.com/Kaigard/Kaigard.github.io/raw/master/img/AIG_ASIC_img/CDC/CDC_Picture2.png)

由公式分析可得，除了tdata可以人为控制以外，其他参数都是固定值。想要最大化降低亚稳态的发生概率，那么触发器之间不能添加任何组合逻辑，以降低Tdata。  

#### 使用双锁存器法解决亚稳态问题

![跨时钟电路设计](https://github.com/Kaigard/Kaigard.github.io/raw/master/img/AIG_ASIC_img/CDC/CDC_Picture3.png)
优点：结构简单易于实现  
缺点：增加了两级延时，不适用于快时钟到慢时钟的同步  

### 单bit信号的跨时钟电路  

#### 边沿检测同步电路  

慢时钟同步到快时钟域  

![跨时钟电路设计](https://github.com/Kaigard/Kaigard.github.io/raw/master/img/AIG_ASIC_img/CDC/CDC_Picture4.png) 

将慢时钟域下的脉冲转换为快时钟域下的一个脉冲。直接同步的化，慢时钟的一个脉冲等于快时钟的好多个脉冲。

#### 脉冲同步器（脉冲展宽）

快时钟同步到慢时钟域   
慢时钟直接采样快时钟很可能采不到，所以要对快时钟信号进行脉冲展宽。  

![跨时钟电路设计](https://github.com/Kaigard/Kaigard.github.io/raw/master/img/AIG_ASIC_img/CDC/CDC_Picture5.png) 

注意事项，时钟域B两级同步的寄存器和时钟域A的输出寄存器之间不能有组合逻辑。组合逻辑电路的各个输入信号的不一致性以及组合逻辑内部延迟时间不一样，运算后信号存在毛刺。想要在B时钟域下采到稳定的信号，时钟域A的信号必须经过clkA敲过，在一个时钟周期内是稳定的信号。

```verilog
`timescale  1ns / 1ps
module sync_pulse (
               input rst_n             , // system reset
               input clka               , // clockA
               input clkb               , // clockB
               input  puls_a_in       , // pulse input from clka
               output puls_b_out     , // pulse output in clkb
               output levl_b_out        // level output in clkb
               );

   parameter DLY = 1; //
   reg  signal_a,signal_b;
   reg  signal_b1_a2,signal_b1_a1;
   reg  signal_b_b1,signal_b_b2;

   always @ (posedge clka or negedge rst_n)
   begin
      if (rst_n == 1'b0)
         signal_a <= # DLY 1'b0 ;
      else if (puls_a_in)
         signal_a <= # DLY 1'b1 ;
      else if (signal_b1_a2)
         signal_a <= # DLY 1'b0 ;
   end

   always @ (posedge clkb or negedge rst_n)
   begin
      if (rst_n == 1'b0)
         signal_b <= # DLY 1'b0 ;
      else
         signal_b <= # DLY signal_a ;
   end

   always @ (posedge clkb or negedge rst_n)
   begin
      if (rst_n == 1'b0) begin
         signal_b_b1 <= # DLY 1'b0 ;
         signal_b_b2 <= # DLY 1'b0 ;
      end
      else begin
         signal_b_b1 <= # DLY signal_b ;
         signal_b_b2 <= # DLY signal_b_b1 ;
      end
   end

   always @ (posedge clka or negedge rst_n)
   begin
      if (rst_n == 1'b0) begin
         signal_b1_a1 <= # DLY 1'b0 ;
         signal_b1_a2 <= # DLY 1'b0 ;
      end
      else begin
         signal_b1_a1 <= # DLY signal_b_b1 ;
         signal_b1_a2 <= # DLY signal_b1_a1 ;
      end
   end

   assign puls_b_out = signal_b_b1 & (~signal_b_b2) ;
   assign levl_b_out = signal_b_b1 ;

endmodule
```

### 多bit信号的跨时钟电路

多bit信号的跨时钟电路一般有三种处理方式：DMUX\格雷码\异步fifo。

#### DMUX
原理：将多Bit数据信号和单bit控制信号成对的从发送时钟域发往接受时钟域，控制信号在接收时钟域以两级同步器（打两拍）的形式接收，多Bit数据信号由同步后的单Bit控制信号控制的MUX决定数据是否通过。  
 
![跨时钟电路设计](https://github.com/Kaigard/Kaigard.github.io/raw/master/img/AIG_ASIC_img/CDC/CDC_Picture6.png) 

#### 格雷码  

关于格雷码，要记住的第一个事实是，任意两个相邻格雷码之间的距离只有1（相邻格雷码数值跳变时，只有一位可以改变）。要记住的第二个事实是，格雷码计数器都是2^n次幂的计数器。可以制作一个计算偶数个序列的灰码计数器，但对这些序列的转换通常不像标准的格雷码那么简单。还要注意，没有奇数长度的格雷码序列，所以人们不能制作一个23深度的格雷码。默认格雷码的深度都是2^ndeep。   

##### 二进制码转换成格雷码

法则是保留二进制码的最高位作为格雷码的最高位;次高位格雷码为二进制码的高位与次高位相异或，其余各位类似。  

![跨时钟电路设计](https://github.com/Kaigard/Kaigard.github.io/raw/master/img/AIG_ASIC_img/CDC/CDC_Picture7.png)   
 
```verilog
module Bin2Gray
#(parameter SIEZ = 4)
(
  input [SIZE - 1 : 0] Bin,
  output [SIZE - 1 : 0] Gray
);
  assign Gray = (Bin >> 1) ^ Bin;    //0异或任何数等于其本身
 
endmodule
 ```  
##### 二进制格雷码转换成二进制码  

法则是保留格雷码的最高位作为自然二进制码的最高位；次高位自然二进制码为高位自然二进制码与次高位格雷码相异或，其余各位类似。  

![跨时钟电路设计](https://github.com/Kaigard/Kaigard.github.io/raw/master/img/AIG_ASIC_img/CDC/CDC_Picture8.png) 

```verilog
module Gray2Bin
#(DataWidth = 8)
(
  input Clk,
  input Rst,
  input [DataWidth - 1 : 0] Gray,
  output reg [DataWidth - 1 : 0] Bin
);
 
  always @(posedge Clk) begin
    if(!Rst) begin
	  Bin <= 'h0;
	end else begin
	  Bin[DataWidth - 1] <= Gray[DataWidth - 1];
	  for(integer i = DataWidth - 1; i > 0, i = i - 1) begin
		Bin[i - 1] <= Bin[i] ^ Gray[i - 1];
	  end
	end
  end  

endmodule
```  
这种写法并不推荐(因为是zk自己写的)，推荐下面这种写法:  

```verilog
module  Gray2Bin
#(DataWidth = 8)
(
  input Clk,
  input Rst,
  input [DataWidth - 1 : 0] Gray,
  output reg [DataWidth - 1 : 0] Bin
)
  
  always @(posedge Clk) begin
    if(!Rst) begin
      Bin <= 'h0;
    end else begin
      for (integer i = 0; i < DataWidth - 1; i = i + 1) begin
        Bin[i] = ^ (Gray >> i);
      end
    end
  end

endmodule
```
> `^`只有单操作数时，将进行自身异或。例如下面伪代码:
   ```verilog
   wire Bin[3:0];
   Ans1 = ^ Bin;            
   Ans2 = Bin[3] ^ Bin[2] ^ Bin[1] ^ Bin[0];
   Ans1 == Ans2;
   ```  

> 第二种写法好处在于真正的并行，Bin的每bit的计算都是并行的，而第一种写法因为Bin各个bit之间的联系，当位数足够大时，其产生的时延与第二种写法相比是巨大的。类似的思想在超前进位加法器和行波进位加法器中也有体现，bit之间的解耦，才是硬件并行的根本。  


#### 异步FIFO
待整理。。。

### CDC面经
* 什么会造成Metastable？

* 如何解决Metastable问题？  

* 多比特数据跨时钟域数据怎么解决亚稳态问题？  

* 跨时钟域可能出现哪些问题？  

* 同步电路和异步电路有什么区别？  

* 同步电路的时序就一定是安全的吗？  

* 跨时钟域数据传输是否和目的时钟域的频率有关？  

* STA分析能否检测跨时钟域问题？  

   不行，STA只能分析同步时钟问题，不能分析异步时钟问题。  

* 跨时钟域问题，能用时钟树综合解决吗（Clock Tree Synthesis，CTS）？ 

   不行，解决问题还是得用上面的方法，比如data hold 问题，快时钟域到慢时钟域的数据传输，如果快时钟域的时钟频率比慢时钟域快很多，那怎么调时钟树，快时钟域一个周期的信号，不可能永远能被慢时钟域抓到，所以综合时钟树不能解决问题。  

* 慢时钟域同步快时钟域格雷码时候，在慢时钟域的一个周期中，经历了两次或多次快时钟域的上升沿，那么对应的格雷码就会有两个或多个bits发生变化，这个不会产生多个bits同步的问题吗？  

   如果写时钟频率很高，相对读时钟是一个快时钟，那么如果读时钟域才读了一个数，写时钟域就写了两三个数,写地址也随之变化了两三次，这是否会引|起多bit跨时钟域的问题呢?举个例子，如果现在同步到读时钟域的格雷码写指针是011,而写时钟快很多，写时钟域的格雷码写指针已经发生变化:011→010→110, 在读时钟域这边，就需要直接同步110,那么，读时钟域的格雷码写指针就会从011变为110,第0位和第2位都发生变化，这会在采样时造成影响吗?  
   雷哥的答案：  
   同步时，只要快时钟每次变化只有bit,那么对于慢时钟来讲，慢时钟永远只可能采样到这1bit变化之前的数据和这1bit变化之后的数据。在此之前的数据都是稳定的。慢时钟不care它是由什么数据变化得到的，因为其他位的数据都是在几个快时钟前变化的了，都是满足慢时钟的建立时间要求的，只有当前同步时，那最近的在变化的1bit数据有可能不满足建立时间要求。即使没采到，也假空也不影响fifo的安全。最多就是晚读一个周期。  
   网上啰嗦的答案：  
   答案是不会。变两位就变两位呀，管他干什么?读时钟域的格雷码写指针是为了去和读指针作比较的，变两位才是好事，变一位反而得不到正确的空信号。进一步地，我们所说的多bit信号跨时钟域传输问题中的多bit是针对源时钟域(即写时钟域)而言的，在之前的例子中，如果不用格雷码，写指针变化顺序为: 010→011→100，在011变为100的过程中，所有位都发生变化，目标时钟域(读时钟域)采样时写指针会无法确定，可能是任意3位二进制数。但是，如果使用了格雷码，变化顺序为: 011→010→110,注意,这个变化次序是逐个的，并不是从011直接变为110,所以,即便读时钟域已经同步了011,写时钟域的写指针又由于变化太快变到了110,同步时刻来临时,采样值也要么是010 (没采到第2位的变化)， 要么是110 (采到第2位的变化)。  
   关键是理清一个点:多bit变化的含义是写时钟域的写指针相对于前一个写时钟域的写指针的变化，而不是写时钟域的写指针相对于读时钟域的写指针之间的变化。如果不使用格雷码，多bit变化将使采样紊乱，使用格雷码，将多bit变化变为单bit变化,就不会采到错误的值，即便采到变化前的值，也是安全、正确的。   

## 基本电路实现(手撕代码)  

### 逻辑运算  
仅用与非或仅用与或非、最小项之和、最大项之积、卡诺图化简、逻辑门的mos管组成，最简逻辑表达式笔试常出现。  

![基本电路实现](https://github.com/Kaigard/Kaigard.github.io/raw/master/img/AIG_ASIC_img/Circuit/Circuit_Picture1.png)   

![基本电路实现](https://github.com/Kaigard/Kaigard.github.io/raw/master/img/AIG_ASIC_img/Circuit/Circuit_Picture2.png)  

### 算数逻辑电路  
#### 4bit超前进位加法器  
``` verilog
module LCA(
    input clk,
    input rst_n,
    input c_i,
    input [3:0] data_a_i,
    input [3:0] data_b_i,
    output [3:0] res_o,
    output c_o
);

    // c0 = c_i
    // c1 = c0p1 + g1
    // c2 = c1p2 + g2 = (c0p1 + g1)p2 + g2 = c0p1p2 + g1p2 + g2
    // c3 = c2p3 + g3 = (c0p1p2 + g1p2 + g2)p3 + g3 = c0p1p2p3 + g1p2p3 + g2p3 + g3
    // c4 = c3p4 + g4 = (c0p1p2p3 + g1p2p3 + g2p3 + g3)p4 + g4 = c0p1p2p3p4 + g1p2p3p4 + g2p3p4 + g3p4 + g4

    wire [3:0] p;
    wire [3:0] g;

    HalfAdder u_HalfAdder(
        .a(data_a_i),
        .b(data_b_i),
        .p(p),
        .g(g)
    );

    assign c1 = (c_i & p[0]) | g[0];
    assign c2 = (c1 & p[1]) | g[1];
    assign c3 = (c2 & p[2]) | g[2];
    assign c_o = (c3 & p[3]) | g[3];  

    assign res_o[0] = c_i ^ p[0];
    assign res_o[1] = c1 ^ p[1];
    assign res_o[2] = c2 ^ p[2];
    assign res_o[3] = c3 ^ p[3]; 

endmodule

module HalfAdder(
    input [3:0] a,
    input [3:0] b,
    output [3:0] p,
    output [3:0] g
);

    assign p = a ^ b;
    assign g = a & b; 

endmodule
```
```verilog
module tb();

	reg c_i;
	reg [3:0] data_a;
	reg [3:0] data_b;
	wire [3:0] res_o;
	wire c_o;
	reg [4:0] res;
	
	
	class seed;
		rand bit [3:0] a;
		constraint a_range {a > 0;}
		 
		rand bit [3:0] b;
		constraint b_range { b > 0; }
		
		rand bit c;
	endclass
	
	reg clk;
	initial clk = 0;
	always #10 clk = ~clk;
	
	
	initial begin
		seed test_seed;
		test_seed = new();
		repeat (2000) begin
			@(posedge clk);
			test_seed.randomize();
			data_a <= test_seed.a;
			data_b <= test_seed.b;
			c_i <= test_seed.c;
			res = data_a + data_b + c_i;
			if((res[3:0] == res_o) && (c_o == res[4])) begin
				$display("xxxxxxxxxxxxxxxxx_ok");
			end else begin
				$display("XXXXXXXXXXXXXXXXX_no");
			end
		end
		#1000
		$finish;
	end
	
	initial begin
		$fsdbDumpfile("xxx.fsdb");
		$fsdbDumpvars();
	end
	

	LCA u_LCA(
		.c_i(c_i),
		.data_a_i(data_a),
		.data_b_i(data_b),
		.res_o(res_o),
		.c_o(c_o)
	);

endmodule
```

#### 除法器实现  
```verilog
module Div (
  input Clk,
  input Rst,
  input [63:0] Divisor,
  input [63:0] Dividend,
  input DivBegin, 
  output reg [63:0] Remainder,
  output reg [63:0] Quotient
);
  
  parameter DivIdel = 4'b0001;
  parameter DivStart = 4'b0010;
  parameter DivRun = 4'b0100;
  parameter DivEnd = 4'b1000;
  
  reg [7:0] DivCounter;
  reg [3:0] CurrentState;
  reg [3:0] NextState;
  
  reg [127:0] RemainderInside;
  reg RemainderCarry;
 
  wire [63:0] ans;
  wire [63:0] UnDivisorInside = ~Divisor + 1;
  wire CarryOut;
  
  CLA_64Bit_Adder CLA_64Bit_Adder_Div(CarryOut, ans, RemainderInside[127:64], UnDivisorInside, 1'b0);
  
   
  always @ (posedge Clk) begin
    if(!Rst) begin
      CurrentState <= DivIdel;
    end else begin
      CurrentState <= NextState;
    end
  end
  
  always @ ( * ) begin
    case (CurrentState) 
      DivIdel : begin
        if(DivBegin) begin
          NextState = DivStart;
        end else begin
          NextState = DivIdel;
        end
      end
      DivStart : begin
        NextState = DivRun;
      end
      DivRun : begin
        if(DivCounter == 7'h40) begin
          NextState = DivEnd;
        end else begin
          NextState = DivRun;
        end
      end
      DivEnd : begin
        NextState = DivIdel;
      end
      default : begin
      
      end
    endcase
  end
  
  always @ ( * ) begin
    case (CurrentState)
      DivIdel : begin
        Remainder = 64'b0;
        Quotient = 64'b0;
      end
      DivStart : begin
        Remainder = 64'b0;
        Quotient = 64'b0;
      end
      DivEnd : begin
        Remainder = RemainderInside[127:64] >> 1;
        Quotient = RemainderInside[63:0];
      end
      default : begin
      
      end
    endcase
  end
 
  always @ (posedge Clk) begin
    if(!Rst) begin
      DivCounter <= 7'h00;
      RemainderInside <= 128'h0;
    end else begin
      case (CurrentState)
        DivStart : begin
          DivCounter <= 7'h00;
          RemainderInside <= {64'h0000_0000_0000_000, Dividend};
        end
        DivRun : begin
          RemainderInside <= (CarryOut == 1) ? {ans[62:0], RemainderInside[63:0], 1'b1} : {RemainderInside[126:0], 1'b0};
          if(DivCounter == 7'h40) begin
            DivCounter <= 7'h00;
          end else begin
            DivCounter <= DivCounter + 1;
          end
        end
        default : begin
        
        end
      endcase
    end
  end
endmodule
```

#### Booth乘法器  

#### Wallace树  

### 通讯协议电路  
#### 串并转换 

#### 分频电路  
（奇数分频，偶数分频），非常基础，华为面试中出现过，不会基本直接挂  
偶数分频：一个计数器，每次计数到N/2-1时，时钟翻转。  
如进行N倍偶数分频，那么可以通过由待分频的时钟触发计数器计数，当计数器从0计数到N/2-1时，输出时钟进行翻转，并给计数器一个复位信号，使得下一个时钟从零开始计数。以此循环下去。这种方法可以实现任意的偶数分频。  

#### 同步FIFO  
<span id="同步FIFO"> </span>  

``` verilog
module SyncFIFO
#(
  parameter DataWidth = 64,
  parameter Deepth = 16
)
(
  input Clk,
  input Rst,
  input [DataWidth - 1 : 0] WData,
  input WInc,
  output reg WFull,
  output reg [DataWidth - 1 : 0] RData,
  input RInc,
  output reg REmpty
);
  
  localparam DeepthBit = $clog2(Deepth);
  
  reg [DeepthBit : 0] WritePoint;
  reg [DeepthBit : 0] ReadPoint;
  
  //empty or full
  assign WFull = ((WritePoint[DeepthBit] != ReadPoint[DeepthBit]) && (WritePoint[DeepthBit - 1 : 0] == ReadPoint[DeepthBit - 1 : 0]));
  assign REmpty = (WritePoint == ReadPoint); 
  
  //write logic
  always @(posedge Clk) begin
    if(!Rst) begin
      WritePoint <= 'h0;
    end else begin
      if(WInc && ~WFull) begin
        WritePoint <= WritePoint + 1;
      end
    end
  end  

  //read logic
  always @(posedge Clk) begin
    if(!Rst) begin
      ReadPoint <= 'h0;
    end else begin
      if(RInc && ~REmpty) begin
        ReadPoint <= ReadPoint + 1;
      end
    end
  end

  DualPortRam
  #(
    .DataWidth(DataWidth),
    .Deepth(Deepth)
  ) 
  u_DualPortRam
  (
    .WClk(Clk),
    .WData(WData),
    .WAddr(WritePoint[DeepthBit - 1 : 0]),
    .WEnc(WInc),
    .RClk(Clk),
    .RData(RData),
    .RAddr(ReadPoint[DeepthBit - 1 : 0]),
    .REnc(RInc)
  );

endmodule
``` 

#### 双口Ram

```verilog
module DualPortRam
#(
  parameter DataWidth = 64,
  parameter Deepth = 16
)
(
  input WClk,
  input [DataWidth - 1 : 0] WData,
  input [$clog2(Deepth) - 1 : 0] WAddr,
  input WEnc,
  input RClk,
  output reg [DataWidth - 1 : 0] RData,
  input [$clog2(Deepth) - 1 : 0] RAddr,
  input REnc
);

  reg [DataWidth - 1 : 0] RamMem [Deepth - 1 : 0];
  //write
  always @(posedge WClk) begin
    if(WEnc) begin
      RamMem[WAddr] <= WData;
    end
  end

  //read
  always @(posedge RClk) begin
    if(REnc) begin
      RData <= RamMem[RAddr];
    end
  end
endmodule
```

#### 深度为1的同步FIFO  
```verilog
module OneDeepthFIFO
#(
  parameter DataWidth = 64,
  parameter Deepth = 1
)
(
  input Clk,
  input Rst,
  input [DataWidth - 1 : 0] WData,
  input WInc,
  output WFull,
  output reg [DataWidth - 1 : 0] RData,
  input RInc,
  output reg REmpty,
  input JumpFlag
);
  
  reg [DataWidth : 0] OneDeepthMem;
  always @(posedge Clk) begin
    if(!Rst) begin
      OneDeepthMem <= 'h0;
    end else if(WInc) begin
      OneDeepthMem[DataWidth - 1 : 0] <= WData;
      OneDeepthMem[DataWidth] <= 1'b1;
    end
  end

  always @(posedge Clk) begin
    if(!Rst) begin
      RData <= `RegZero;
    end else if(RInc) begin
      RData <= OneDeepthMem[DataWidth - 1 : 0];
      OneDeepthMem[DataWidth] <= 1'b0;
    end
  end
  
  assign WFull = OneDeepthMem[DataWidth];
  assign REmpty = !OneDeepthMem[DataWidth];

endmodule
```
  
#### 握手协议  

#### 序列检测  

#### 模三除法器  
```verilog
module ModThree(
	input clk,
	input rst_n,
	input data,
	output reg res
);
	
	localparam Idel = 2'b00;
	localparam ModOne = 2'b01;
	localparam ModThree = 2'b10;
	
	reg [1:0] currentState;
	reg [1:0] nextState;
	
	always @(posedge clk or negedge rst_n) begin
		if(~rst_n) begin
			currentState <= Idel;
		end else begin
			currentState <= nextState;
		end
	end 
	
	always @( * ) begin
		case (currentState)
			Idel : begin
				if(data) begin
					nextState = ModOne;
				end else begin
					nextState = Idel;
				end
			end 
			ModOne : begin
				if(data) begin
					nextState = ModThree;
				end else begin
					nextState = Idel;
				end
			end
			ModThree : begin
				if(data) begin
					nextState = ModThree;
				end else begin
					nextState = Idel;
				end
			end
			default : begin
				nextState = Idel;
			end
		endcase
	end
	
	always @(posedge clk or negedge rst_n) begin
		if(~rst_n) begin
			res <= 1'b0;
		end else begin
			case (currentState)
				Idel : begin
					res <= 1'b0;
				end
				ModOne : begin
					if(data) begin
						res <= 1'b1;
					end else begin
						res <= 1'b0;
					end
				end 
				ModThree : begin
					if(data) begin
						res <= 1'b0;
					end else begin
						res <= 1'b1;
					end
				end
				default : begin
					res <= 1'b0;
				end
			endcase
		end
	end

endmodule
```

``` verilog
module tb();

	reg  rst_n;
	reg  data;
	reg  res;
	reg  res_ref;
	
	bit q[$] = {0,0,0};
	
	class seed;
		rand bit a;
	endclass
	
	reg clk;
	initial clk = 0;
	always #10 clk = ~clk;
	
	
	initial begin
		seed test_seed;
		test_seed = new();
		rst_n = 1'b0;
		@(posedge clk);
		rst_n = 1'b1;
		repeat (2000) begin
			@(posedge clk);
			test_seed.randomize();
			data <= test_seed.a;
			q.pop_front;
			q.push_back(data);
			//$display(q);
			res_ref <= (q[0] == 1 && q[1] == 1 && q[2] == 0) || (q[0] == 0 && q[1] == 1 && q[2] == 1);
			if(res_ref == res) begin
				$display("XXXXXXXXXX_OK");
			end else begin
				$display("XXXXXXXXXX_NO");
			end
		end
		#1000
		$finish;
	end
	
	initial begin
		$fsdbDumpfile("xxx.fsdb");
		$fsdbDumpvars();
		$fsdbDumpMDA();
	end

	ModThree u_dut(
		.clk(clk),
		.rst_n(rst_n),
		.data(data),
		.res(res)
	);

endmodule
```


#### 找1的个数
写法1：  
```verilog
module CheckOne(
	input clk,
	input rst_n,
	input [7:0] data,
	output reg [2:0] num
);
	
	always @( * ) begin
		num = 3'b0;
		for(integer i = 0; i < 8; i++) begin
			if(data[i]) begin
				num = num + 1;
			end
		end
	end
endmodule
```
写法2： 咕咕咕。。。


#### 是否为2的次方
写法1：
```verilog
module PowerOf2(
	input [7:0] data,
	output ya
);

	wire [7:0] res = data & ~(~data + 1);

	assign ya = |res; 
	
endmodule
```
写法2：
```verilog
module PowerOf2(
	input [7:0] data,
	output ya
);

	wire [7:0] res = data & (data - 1);

	assign ya = |res;
	
endmodule
```
>>> 位运算有很多奇技淫巧，可以参照整个链接[!这是个链接](https://www.zhihu.com/question/38206659/answer/736472332)


#### 异步FIFO
```verilog


```

#### 无毛刺时钟切换  
##### 毛刺的成因（竞争冒险） 
毛刺的原因：逻辑门中不同信号时延不同。  

##### 无毛刺时钟切换   
无毛刺时钟切换电路，又叫 Glitch free 电路、时钟无缝切换电路
随着越来越多的多时钟应用于当今的芯片中（尤其是在通信领域），在芯片运行时经常需要切换时钟源。通常的实现方式是：在硬件中复用两个不同频率的时钟源，并通过内部逻辑控制复用器 MUX。  
这两个时钟在频率上可能完全不相关，也可能成倍数关系。不管是哪种情况，都有可能在开关门控时产生毛刺（Glitch）。时钟线上的毛刺对整个系统是危险的，因为它可能使用边沿触发了部分寄存器，而其他寄存器却没被触发。  
下面使用两种不同的方式来避免输出时钟上有毛刺。第一种方法适用于两个时钟的频率有倍数关系，第二种方法适用于两个无关的时钟。  
1.实时的时钟切换问题    

![基本电路实现](https://github.com/Kaigard/Kaigard.github.io/raw/master/img/AIG_ASIC_img/Circuit/Circuit_Picture3.png)   
当 SELECT 的值发生变化，输出时钟从当前的时钟源切换到下一个时钟源，此时可能会产生毛刺。  
![基本电路实现](https://github.com/Kaigard/Kaigard.github.io/raw/master/img/AIG_ASIC_img/Circuit/Circuit_Picture4.png) 

2.相关时钟的无缝切换  
在每个时钟源的选择路径上，都插入一个下降沿有效的 D 触发器。之所以插入下降沿有效的D触发器，是为了保证，时钟在安全的位置进行切换。在时钟的每个下降沿寄存选择控制信号 SELECT，并且只有在其他时钟的选择被释放后（无效后）才会使能新的时钟选择，这样对输出毛刺问题进行很好的解决。  
在时钟的下降沿处寄存选择控制信号，保证了控制信号不会在 2 个时钟源的高电平处进行跳变，这样就防止对输出时钟进行截断（截断导致毛刺）。  
假设此时 SELECT 在适中的高电平处进行了跳变，由于与门作用，需要等待其另一个时钟触发的寄存器输出 QN 也变化为 1 时，与门的结果  SELECT-1 才会变化，而 QN 的变化需要等待到时钟的下降沿才会变化，所以经过处理后的SELECT-1 信号的跳变只发生在时钟的低电平处。    
![基本电路实现](https://github.com/Kaigard/Kaigard.github.io/raw/master/img/AIG_ASIC_img/Circuit/Circuit_Picture5.png)  

在这个电路中有 3 条时序路径需要特别考虑：  
* SELECT 控制信号到任意一个下降沿有效的触发器；
* DFF0 的输出到 DFF1 的输入；
* DFF1 的输出到 DFF0 的输入。  
如果这三条路径中的任一路径上的信号在目的寄存器时钟的捕获沿时发生变化，则寄存器的输出有一定的机会会进入亚稳态（meta-stable），这意味着会进入理想的 0 和 1 之间的一个状态。(在此例中，捕获沿均为下降沿)。  
亚稳态经过一段时间后会 随机的 稳定为 0 或者 1，这就导致两个寄存器可能采集到不同的值（一个认为是 0，而另一个认为是 1）。因此，这就要求两个寄存器捕获沿和 对 SELECT 信号的发起沿分开，以避免任何可能的异步接口。由于两个时钟源的时序关系是已知的，所以上述可以通过使用恰当的多周期约束（multi-cylce hold）或者最小延时（minimun delay）约束来实现。  
![基本电路实现](https://github.com/Kaigard/Kaigard.github.io/raw/master/img/AIG_ASIC_img/Circuit/Circuit_Picture6.png)  


3.不相关时钟的无缝切换  
在前一种避免输出毛刺的门控选择方式中，要求两个输入时钟源的频率有倍数关系，这样使用者可以（通过使用恰当的时序约束）避免信号与任何一个时钟域异步。这种实现方式没有处理异步信号的机制。  
这样，提出第二种实现方式，使用同步电路来避免异步信号带来的潜在的亚稳态风险。当两个时钟源完全不相关时，异步行为可能来自 SELECT，也可能来自另一个时钟域的异步的反馈信号。  
如图 3-1 所示，对每个时钟源路径上，各增加一个该时钟源上升沿驱动的触发器来避免亚稳态。时钟源路径上增加的上升沿有效的触发器，与现有的下降沿有效的触发器一起，用于减少 SELECT 或者异步反馈信号导致的潜在的亚稳态的概率。  
使用简单的两级寄存器搭建的同步器，第一级的寄存器通过锁存数据来稳定数据，然后将稳定后的数据传输到第二级的触发器，由电路中的其他部分来解释。  
![基本电路实现](https://github.com/Kaigard/Kaigard.github.io/raw/master/img/AIG_ASIC_img/Circuit/Circuit_Picture7.png)   

![基本电路实现](https://github.com/Kaigard/Kaigard.github.io/raw/master/img/AIG_ASIC_img/Circuit/Circuit_Picture8.png)    

 
