---
layout:       post
title:        "数字IC不完全指南"
author:       "Lei Dong, Kai Zhou"
header-style: text
catalog:      true
tags:
    - ASIC
    - Guide
---

## 序-写在前面
该文档由东南大学20届学长整理创建。文档整理了数字ic设计全流程中涉及的相关知识以及秋招面试时重点考察的知识点。
文档整理的目的在于让新手icer在短时间内迅速成为一名知识面广，基本功扎实的数字ic工程师。让实验室同学从研一入学时起，就少走弯路，有目标有计划地学习数字ic知识。
文档的整理建立在个人知识体系之上，只涉及数字ic设计中的基础知识，且难免会受限于经验的不足，眼界的狭隘而出现谬误，欢迎添加微信dl961231联系笔者对文档整理出现的谬误进行指正和讨论。
本文的成文借鉴了大量前辈在网络上无私分享的知识总结，知识是无价的，但是正是这些前辈将他们的学习经验无私的分享出来，才为中国的ic行业注入了动力，增添了活力，拉高了行业的整体知识水平。在这里，我效仿各位前辈花了些许时间，对ic知识进行了一个总结归纳。希望本文档能够对后续进入本专业的同学有所助益，并且我希望凡是从本文档中获得助益的同学能够把无私的精神，分享的地精神传承下去，以包容进取的精神分享知识给周围人。越分享越幸运，知识烂在肚子里不会让你比别人更强，只会让人固步自封停滞不前！
另外，对于实验室本门的学弟学妹，我提出要求，希望学弟学妹每年对该文档进行一次改版、补充和再整理，希望你们能够站在前人的肩膀上拥有更广阔的视野，成就更高的高度。
最后，我与所有进入数字ic领域的硅友们共勉：天道酬勤，大器晚成！

by 董雷  
2022/04/25
  
<br> 

## 修订日志
| Rev. |  Date  |  Author  |  Description |  
| ---- | ---- | ---- | ---- |
| 1.0 | 2022/04/25 | 董雷 | 初版 |  
|     |            |       |      |

<br> 

## verilog语法

### VerilogHDL 可综合概述

1.Verilog HDL的基本功能之一是描述可综合的硬件电路。如何合理使用Verilog HDL描述高性能的可综合电路是本次课的主旨之一。相比C语言，最显著的区别在与HDL语言具备以下硬件设计的基本概念：
互连(connectivity)：wire型变量描述各个模块之间的端口与网线连接关系。
并发(concurrency): 可以有效地描述并行的硬件系统。
时间(time): 定义了绝对和相对的时间度量，可综合操作符具有物理延迟。
C语言是一种软件语言，所以并无上述硬件对象。  

2.硬件描述语言描述的电路，最终将通过逻辑综合工具、布局布线工具将其实现为芯片。但是，并不是verilog中所有的关键词都可以被综合为硬件电路。通常，有四个最常用的关键字被用来综合电路，分别是 `always`、`if-else`、`case`、`assign`，我们称之为可综合四大法宝。除此之外还有很多关键字。那么verilog 中众多的关键字有什么存在价值呢？这些不可综合的关键字都可以用于书写testbench。  
* 所有综合工具都支持的结构: `always`,&nbsp; `assign`,&nbsp; `begin`,&nbsp; `end`,&nbsp; `case`,&nbsp; `wire`,&nbsp; `tir`,&nbsp; `apply0`,&nbsp; `supply1`,&nbsp; `reg`,&nbsp; `integer`,&nbsp; `default`,&nbsp; `for`,&nbsp; `function`,&nbsp; `and`,&nbsp; `nand`,&nbsp; `or`,&nbsp; `nor`,&nbsp; `xor`,&nbsp; `xnor`,&nbsp; `buf`,&nbsp; `not`,&nbsp; `bufif0`,&nbsp; `bufif1`,&nbsp; `notif0`,&nbsp; `notif1`,&nbsp; `if`,&nbsp; `inout`,&nbsp; `input`,&nbsp; `instantitation`,&nbsp; `module`,&nbsp; `negedge`,&nbsp; `poesedge`,&nbsp; `operators`,&nbsp; `output`,&nbsp; `parameter`.
* 所有综合哦工具都不支持的结构: `time`,&nbsp; `defparam`,&nbsp; `$finish`,&nbsp; `fork`,&nbsp; `join`,&nbsp; `initial`,&nbsp; `delays`,&nbsp; `UDP`,&nbsp;, `wait`.
* 有些工具支持有些工具不支持的结构: `casex`,&nbsp; `casez`,&nbsp; `wand`,&nbsp; `triand`,&nbsp; `wor`,&nbsp; `trior`,&nbsp; `real`,&nbsp; `disable`,&nbsp; `forever`,&nbsp; `arrays`,&nbsp; `memories`,&nbsp; `repeat`,&nbsp; `task`,&nbsp; `while`.  

3.其中`for`语句被用来综合时，循环变量需要是常数，但是仍然不推荐使用`for`语句进行综合。  

4.`function`被用来综合时，一般是用来描述组合逻辑电路。  

#### 常见可综合语法与硬件的映射关系

1.`if-else` 通常会被逻辑综合其映射为多路选择器，输出结果由输入的条件决定。需根据设 计目标，小心设计：先“加”后“选”，先“选”后“加”。  

2.对于单 `if` 语句，逻辑综合工具会将其映射为<font color=red>无优先级</font>的判断结构。推荐初学者尽量使用 单 `if` 语句(`if...else if...else if...`) 描述多条件判断结构。
>此处zk认为单`if`语句也是有优先级的结构: [单击前往](https://blog.csdn.net/weixin_39520719/article/details/107809003)

3.多 `if` 语句，逻辑综合工具会将其映射为有优先级的判断结构。最后一级选择信号具有最 高优先级。具有优先级的多选结构会消耗组合逻辑。不推荐这种写法，有点乱。  

4.若某些设计中，有些信号要求先到达(如关键便能信号、选择信号等)，而有些信号需要 后到达(如慢速信号、有效时间较长的信号等)，此时则需要使用 `if...if...`结构。设计方法： 最高优先级给最迟到达的关键信号。  

5.`case`是一种无优先级的判断结构。与单`if` 语句的区别是，`case` 的条件互斥。多用于指令译码电路。  

#### 电路设计需要注意的基本事项

1.慎用latch。逻辑综合工具很难解释 latch，因此，除非特殊用途，一般避免引入 latch。 

2.易引入 latch 的途径，一般是使用不完备的条件判断语句。防止产生非目的性 Latch 的 措施主要有：使用完备的 `if...else` 语句；为每个输入条件设计输出操作，为 `case` 语句设 置 `default` 操作；仔细检查综合器生成的报告，latch 会以 warning 的形式报告。 

3.在电路设计的过程中，如果发现某个电路的负载比较多，则可以通过逻辑复制，降低关 键信号的扇出，进而降低该信号的传播延迟，提高电路性能。 

4.如果我们发现电路中存在较多的公共单元，也可以通过资源共享的方式，减小面积。但是，一般来说，共享会导致性能下降，所以还要根据性能和面积进行取舍。 

5.在设计电路的时候，我们也可以根据数据的延迟，对这些资源进行顺序重排，降低传播延迟。如图所示，A 信号到来比较晚，我们就可以把它尽可能放到后面，隐藏其延迟。 

6.最后一个小建议。在代码书写过程中，尽可能使用 `always` 描述电路，`assign` 仅仅用来连线。少用?:这种形式，因为这种形式通常难以阅读，且多层嵌套后很难被综合器解释。 

7.所有的组合逻辑或锁存的 `always` 结构必须有敏感信号列表。这个敏感信号列表必须包含所有的输入信号。综合过程将产生一个取决于除敏感列表中所有其它值的结构，它将可能在行为仿真和门级仿真见产生潜在的失配。 

8.在综合过程中，每个 Verilog `always` 块敏感信号列表只能对应一个时钟。原因：这是将每一个过程限制在单一寄存器类型的要求，有利于逻辑综合和静态时序分析。  

9.不允许 `Wait` 声明和`# delay` 声明。`Wait` 声明语句，不论是清楚还是含糊，都不能用于可综合设计。从 RTL 级转换到 gate 级的综合工具一般都不支持 `Wait` 声明和`# delay`声明，为了有效的综合，这些语句应该避免。在不需要进行综合的行为模块中，如测试模块、表示行为的虚拟器件模块中可以使用。 

10.在时序电路中必须使用非阻塞赋值(`<=`)，组合逻辑电路必须使用阻塞赋值(`=`)，这个一定要注意，严格按这个要求写。 

11.分开异步逻辑与同步逻辑。避免综合和静态时序时碰到问题，简化约束和编码难度。

12.不可应用于非综合模块中（例如：总线模块，总线监视器或是模拟模块）除非他们被设计来综合仿真。 

13.分开控制逻辑和存储器，建议控制逻辑和存储器逻辑分成独立的模块。通常来说，存储器是用 memory compiler 生成的，其综合方式与 RTL代码不同，所以混在一起，不利用综合，不利于很方便地更换工艺库和平台。

<br>

### 可综合风格——在RTL书写中如何考虑延迟、面积等。

1.多路选择器构成的级联电路中，如果有个别信号到来的比较晚。那如何针对这个信号进行优化呢？尽可能把这个延迟较大的分支单独拿出来，放到离出口最近的选择器中。 

2.注意“先加后选”和“先选后加”两种方法对数据通道延迟的影响。先选后加，会使控制通道延迟变大。 

3.重点关注电路中的加法器、乘法器等较为复杂的逻辑单元，尽可能少使用。 

4.随着芯片工艺的进步和生产成本的降低，面积显得没有时序问题重要。但减少设计面积意味着成本降低、功耗降低，特別是对于 FPGA 的设计，直接决着 FPGA 的选型。一般综合过程中可以对面积进行优化，但在 RTL 编码中如果注意节约设计面积，往往可以达到事半功倍的效果。 

5.要减少设计的面积，首先应该学会估计设计使用资源的数量,如使用了多少个触发器、
加法器、乘法器。这个过程也可以借助一些工具完成。最终应该知道设计中哪些部分占
用了较大的面积，进而分析改进的方法。 

6.一般来说，触发器的数量由功能决定，很难减少，同时触发器的面积比较好估计，因此和时延问題一样，组合逻辑是改进的攻点。对应到 RTL 代码，就是各种操作符。因此，应该了解各种操作符会产生的电路。要知道，RTL 代码屮的一个`+`可能对应着一个 64位的加法器。以下这些操作符都可能产生较大 的组合逻辑，使用时应加以重视，如`+`、`-`、`×`、`÷`以及条件语句中 的比较运算。对于这些操作，首先应该判断其必要性，是否能用更简单的运算代替。  

7.如果，必须使用复杂的运算符，则应考虑是否可以资源共享。尽管电路逻辑综合工具也会在综合的过程中采用资源共享的方法进行优化，但是，综合器的策略是有限的，因此，在编写 RTL 的时候，应该尽量考虑共享，而不是把这项工作完全留给综合工具。  

8.除了操作符，多比特的信号也往往会占用较大的资源，因为使用这些信号的操作都是对所有的比特进行的，相当于成倍使用资源，因此，对这类信号的操作也应重视。  

9.除此之外，针对不同的设计，还有可能有各种各样的优化和改进的方法，但是，归结到一点，就是编写代码时，应对操作符有足够的重视，对有可能简化的地方尽量简化。逻辑简化往往在减少面积的同时也减少了延迟，因此，是值得花费一些时间的。  

10.对于功耗控制，主要措施包括如下：
* 门控时钟，门控时钟是电路设计最常用也是最有效的方法，在逻辑综合阶段可以让综合工具自行插入。
* 增加使能信号，使得部分电路只有在需要工作时才工作；
* 对芯片各个模块进行控制，在需要工作时才工作；
* 除了有用信号和时钟的翻转会消耗功耗，组合逻辑产生的毛刺也会大量消耗功耗。但是，毛刺在设计中无法避免，因此，只有尽量减少毛刺在电路中的传播，才可以减少功耗。即，在设计中，尽量把产生毛刺的电路放在传播路径的最后。另外，可以使用一些减少毛刺的技术。
* 对于有限状态机，可以通过低功耗编码（参考格雷码的特性4.3.2节）来减少电路的翻转。总的来说，使用这些技术时，应首先考虑全局的功耗控制；然后再 RTL 编码中，注意消耗功率较多的电路，如状态机、译码器、多路选择器等。最后，在综合中，使用门控时钟和其他减少功耗的优化技术。这里要注意下门控时钟和增加使能控制的区别。增加使能仅仅是使得电路的输出信号不再翻转，但是输入时钟每个周期还会继续翻转。而门控时钟则是直接关掉输入时钟，这种方法效果更好。  

11.如果可以在 RTL 编码 阶段考虑代码可能对布线产生的影响，就可能避免最后出现无法布通的情况。布线阶段，通常热点是一个影响布线质量的问题。我们在 RTL 阶段应该重视这种电路，及早发现可能在布线阶段产生的问题。如果设计的功能中确实需要采用大的 mux，可以通过其他方式改变他的结构。其基本的思路是将一个大的 mux 分解为多级较小的 mux。

<br>

### RTL设计指导原则

#### 概述 

RTL 级设计的评判标准很多，如时序性能、所占面积、可测试性、可重用性、功耗、时 钟域的分配、复位信号设计以及是否与所用 EDA 工具匹配等。如果设计目标是在 FPGA 或 CPLD 等可编程逻辑器件上实现，则还需考虑是否能发挥这些 PLD 的结构特点等。根据这些目标的组合和优先级设置，可以派生出很多不同的设计原则。这里仅讨论一般意义的指导 原则。通常来说，主要有三个指导原则：面积与速度互换、乒乓操作、流水线设计。 

我们先来讲面积与速度互换原则。这里的“面积”是指一个设计所消耗的目标器件(如FPGA 、CPLD 和 ASIC 等)的硬件资源数量或者 ASIC 芯片的面积。对于 FPGA 来说， 可以用所消耗的触发器 CFF) 和查找表 CLUT)数量来衡量；对于 ASIC 来说，则可以用设 计的面积、门数等衡量。"速度"指设计在芯片上稳定运行时所能够达到的最高频率，这个频 率由设计的时序状况决定，与设计满足的时钟周期、PAD to PAD Time 、Clock Setup Time 、 Clock Hold Time 和 Clock-to-Output Delay 等众多时序特征量密切相关。 

面积和速度这两个指标贯穿于 RTL 设计的始终，是衡量设计质量的终极标准。这里讨 论一下设计中关于面积和速度的基本原则，即面积和速度的平衡与互换原则。作为矛盾的两个方面，面积和速度的地位是不一样的。相比之下，满足时序、工作频率的要求更重要一些，所以当两者发生冲突时，应采用速度优先的原则。 面积和速度的互换是 RTL 设计的一个重要思想。从理论上讲，一个设计如果时序余量 较大，所能跑的频率远远高于设计要求，那么就能通过功能模块复用减少整个设计所消耗的 芯片面积，也就是用速度的优势对换面积的节约。 

反之，如果一个设计的时序要求很高，普通方法达不到设计频率，那么一般可以通过将 数据流串并转换，井行复制多个操作模块，对整个设计采取"乒乓操作"和"串并转换"的思想 进行处理，在芯片输出模块处再对数据进行"井串转换"。
从宏观上看，整个芯片满足了处理速度的要求，这相当于用面积复制换取速度的提高。面积和速度互换的操作技巧很多，比如模块复用、"乒乓操作"、"串井转换"等，这些技巧需 要不断积累。 

#### 乒乓操作 
乒乓操作的最大特点是通过“输入数据选择单元”和“输出数据选择单元”按节拍、相互配 合的切换，将经过缓冲的数据流没有停顿地送到“数据流运算处理模块”进行运算与处理。把乒乓操作模块当做一个整体，站在这个模块的两端看数据，输入数据流和输出数据流都是连续不断的，没有任何停顿，因此非常适合对数据流进行流水线式处理。所以乒乓操作常常应用于流水线式算法，完成数据的无缝缓冲与处理。乒乓操作的第二个优点是可以节约缓冲区空间。另外，巧妙运用乒乓操作还可以达到**用低速模块处理高速数据流的效果**。  
![乒乓操作](https://github.com/Kaigard/Kaigard.github.io/raw/master/img/AIG_ASIC_img/Picture1.png)   

通过乒乓操作实现低速模块处理高速数据的实质是：通过 DPRAM 这种缓存单元实现了数据流的串并转换，并行用“数据预处理模块 1”和“数据预处理模块 2”处理分流的数据，是面积与速度互换原则的体现！  
![乒乓操作](https://github.com/Kaigard/Kaigard.github.io/raw/master/img/AIG_ASIC_img/Picture2.png)  

假设A输入数据速率是100m，第一个cycle将数据送入B1,第二个cycle将数据送入B2，第三个cycle将数据送入B1,依次反复送入B2\B1\B2。那么可以简单的得知，数据预处理模块的处理数据能力仅要求50m。  
时序图如下：   
![乒乓操作](https://github.com/Kaigard/Kaigard.github.io/raw/master/img/AIG_ASIC_img/Picture3.png)   

#### 流水线
流水线的参数设计中，系统时钟取决于最慢的流水线级的延时。 流水线分割点及级数的确定要考虑的因素包括：单元延迟时间及时钟频率的大小决定了数据通过速率，过多的级数不一定能产生最快的结果；太多寄存器的插入会导致芯片面积增加，布线困难，时钟偏差增加。  

流水线设计就是把规模较大、层次较多的组合逻辑电路分为几个级别，在每一级插入寄存器组暂存中间数据。例如K级的流水线就是从组合逻辑的输入到 输出恰好有K个寄存器组(分为K级，每一级都有一个 寄存器组)，上一级的输出是下一级的输入而又无反馈的电路。  

流水线技术主要应用在算术模块中。加法运算是最基本的DSP运算，减法、乘法、除法或 FI丌运算都可分解为加法运算。因此进行加法运算的加法器就成为实现DSP的最基本器件，所以研究如何提高 其运行速度很有必要。流水线技术在提高系统整体运行 速度方面绩效显著，因而采用流水线技术的加法器就成为继串联加法器、并行加法器之后在选择加法器时的首选。 
举个例子：如计算log(|a+b|)  
不插入流水线，一个clk内算出计算结果:  
![流水线](https://github.com/Kaigard/Kaigard.github.io/raw/master/img/AIG_ASIC_img/Picture4.png)  
电路的最小周期取决于: Tcq+Tadd+Tabs+Tlog+Tsu  
插入流水线，加法器组合逻辑后加寄存器、在求绝对值组合逻辑后加寄存器、在求对数组合逻辑后加寄存器。也就是3个时钟后才能得到数据的计算结果: 
![流水线](https://github.com/Kaigard/Kaigard.github.io/raw/master/img/AIG_ASIC_img/Picture5.png)  
电路的最小周期取决于: Tcq+max(Tadd+Tabs+Tlog)+Tsu  

> 一道题目:
> ![流水线](https://github.com/Kaigard/Kaigard.github.io/raw/master/img/AIG_ASIC_img/Picture6.png)  
> ![流水线](https://github.com/Kaigard/Kaigard.github.io/raw/master/img/AIG_ASIC_img/Picture7.png)
  
<br>  

## System Verilog
wating...  

<br>

## 同步电路  

### 同步电路的相关概念
同步电路的定义：同步电路即电路中所有受时钟控制的单元，全部由一个统一的全局时钟控制。

同步电路设计的优点：
* 在同步设计中，EDA工具可以保证电路系统的时序收敛，有效避免了电路设计中竞争冒险现象。
* 由于触发器只有在时钟边缘才改变取值，很大限度地减少了整个电路受毛刺和噪声影响的可能。
* EDA工具的支持，可以方便的进行STA检查。  

同步电路设计的缺点:
* 时钟偏斜（Clock Skew） 由电路中不同寄存器距离时钟源点的距离不同所产生，也就是时钟到达不同路径的时间不一致，相差的时间就是时钟偏斜。
* 时钟抖动（Clock Jitter）
* 时钟树综合，需要加入大量的延迟单元平衡以上影响，使得电路的面积和功耗大大增加。  

### 异步电路的相关概念
异步电路定义：电路中没有一个全局的或局部的控制时钟，电路中的数据传输可以在任何时候发生。
> **注意!** 如果不同时钟是从同一个PLL分频出来的，那么这些不同时钟的频率和相位互相之间是可控和明确的。这些不同时钟仍然属于同步时钟。

![yibu](./img/Picturex.png)

异步电路的优点：
* 模块化特性突出
* 对信号的延迟不敏感
* 没有时钟偏斜问题
* 有潜在的高性能特性
* 好的电磁兼容性
* 具有低功耗的特性  

异步电路的缺点：
* 设计复杂
* 缺少相应的EDA工具的支持
* 在大规模集成电路设计中应该避免采用异步电路设计 

由于EDA工具的广泛支持，采用同步电路设计的方法是目前ASIC和SOC设计的基本要求，但是通常大规模ASIC和SOC芯片都采用了全局异步、局部同步的方法。因此必须注意异步信号与同步电路的交互问题。
>实际上，成熟的CPU(Cortex-M0、Cortex-M3等)均采用异步复位电路，因为在CPU此类设计中可以采用大量手段规避缺点。

### 异步复位同步释放

#### 同步复位

优点：
* 有利于仿真器的仿真。
* 可以使所设计的系统成为100%的同步时序电路，这大大有利于时序分析，而且综合出来的fmax一般较高。
* 因为它只有在时钟有效电平到来时才有效，所有可以滤除高于时钟频率的毛刺。  

缺点：
* 复位及时性较差，复位有效时间要求大于一个时钟周期。
* 由于常见的基础单元为异步复位的DFF,若要配置成同步复位的话，需要加一些额外的组合逻辑，当巨量的复位需求时，硬件资源的消耗不可忽视。  

#### 异步复位  

异步复位指，复位信号与时钟信号没有特定的相位关系，注意这里是复位信号的触发和释放与时钟信号均无相位关系。从复位信号的下降沿开始，复位信号即处于有效阶段，后续模块会被立即复位。  

优点：复位及时性强，跳变时刻即触发复位，对复位持续时间无特殊要求。  
缺点：由于异步复位信号缺少与时钟的约束，其释放有可能落入恢复和去除时间（类似同步电路中的建立保持时间）。容易为电路带来亚稳态的风险。 

#### 异步触发同步释放复位及Verilog设计  

异步触发同步释放结合了异步的立即复位的优点与同步复位的无亚稳态产生的优点，在复位信号触发时，采用异步复位的即时触发；在复位信号释放时，采用同步信号的上升沿释放。    
构建方法：使用两级触发器级联，异步复位，同步释放即可。

### 状态机

#### 状态机的基本概念  

>状态机体现了设计师的设计功底，是电路时序逻辑设计的重要组成部分。  

状态机的本质：对具有逻辑顺序和时序规律的一种描述方法。  
基本要素： 状态 + 输入 + 输出 
状态机的分类：米勒型、摩尔型，其中米勒型状态机的输出是输入的函数，而摩尔型状态机的输出与输入无关。  

#### 如何写好状态机  

使用HDL语言描述状态机有一定的灵活性，但不能天马行空，有一定的规律可行。
状态机一般可以分为一段式状态机、二段式状态机、三段式状态机。

#### 二段式状态机与三段式状态机  

二段式：状态切换用时序逻辑，次态判断和信号输出用组合逻辑。  
三段式：状态切换用时序逻辑，次态判断用组合逻辑，信号输出用时序逻辑。  

<br>

## 跨时钟电路设计（CDC）

跨时钟电路主要分为这几种：双锁存器法、单bit信号跨时钟域、多bit指示信号跨时钟域、多bit数据跨时钟传输。其中单bit信号的跨时钟域电路又分为漫时钟到快时钟，快时钟到漫时钟。

### 亚稳态

亚稳态是指触发器无法在某个规定时间段内达到一个可确认的状态。
当一个触发器进入亚稳态时，既无法预测该单元的输出电平，也无法预测何时输出才能稳定在某个正确的电平上。
在这个期间，触发器输出一些中间级电平，或者可能处于振荡状态，并且这种无用的输出电平可以沿信号通道上的各个触发器级联式传播下去。
亚稳态不能从根本上消除，但可以通过采取一定的措施使其对电路造成的影响降低。

#### 计算公式
故障间隔平均时间：
![公式](./img/Picturex.png)
>tmet -- 寄存器从时钟上升沿出发后的时序裕量时间  
=采样时钟周期时间 - 输出信号正常的Tcq时间 - 数据到达下一级寄存器的输入端口的其他延时时间Tdata(组合逻辑时延) - 下一级寄存器Tsu时间 - 时钟网络延时时间Tclk2 - Tclk1  
fclk - 接受时钟域的时钟频率  
fdata - 数据的变化频率  
C1、C2 - 与器件有关的参数 （固定值）
  
![结构](./img/Picturex.png)  

由公式分析可得，除了tdata可以人为控制以外，其他参数都是固定值。想要最大化降低亚稳态的发生概率，那么触发器之间不能添加任何组合逻辑，以降低Tdata。  

#### 使用双锁存器法解决亚稳态问题

![图3-1](./img/Picturex.png)  
 优点：结构简单易于实现  
 缺点：增加了两级延时，不适用于快时钟到慢时钟的同步  

 ### 单bit信号的跨时钟电路  

 #### 边沿检测同步电路  

 慢时钟同步到快时钟域  

 ![边沿检测同步电路](./img/Picturex.png)   

将慢时钟域下的脉冲转换为快时钟域下的一个脉冲。直接同步的化，慢时钟的一个脉冲等于快时钟的好多个脉冲。

#### 脉冲同步器（脉冲展宽）

快时钟同步到慢时钟域   
慢时钟直接采样快时钟很可能采不到，所以要对快时钟信号进行脉冲展宽。  

 ![脉冲同步器](./img/Picturex.png)   

注意事项，时钟域B两级同步的寄存器和时钟域A的输出寄存器之间不能有组合逻辑。组合逻辑电路的各个输入信号的不一致性以及组合逻辑内部延迟时间不一样，运算后信号存在毛刺。想要在B时钟域下采到稳定的信号，时钟域A的信号必须经过clkA敲过，在一个时钟周期内是稳定的信号。

```verilog
`timescale  1ns / 1ps
module sync_pulse (
               input rst_n             , // system reset
               input clka               , // clockA
               input clkb               , // clockB
               input  puls_a_in       , // pulse input from clka
               output puls_b_out     , // pulse output in clkb
               output levl_b_out        // level output in clkb
               );

   parameter DLY = 1; //
   reg  signal_a,signal_b;
   reg  signal_b1_a2,signal_b1_a1;
   reg  signal_b_b1,signal_b_b2;

   always @ (posedge clka or negedge rst_n)
   begin
      if (rst_n == 1'b0)
         signal_a <= # DLY 1'b0 ;
      else if (puls_a_in)
         signal_a <= # DLY 1'b1 ;
      else if (signal_b1_a2)
         signal_a <= # DLY 1'b0 ;
   end

   always @ (posedge clkb or negedge rst_n)
   begin
      if (rst_n == 1'b0)
         signal_b <= # DLY 1'b0 ;
      else
         signal_b <= # DLY signal_a ;
   end

   always @ (posedge clkb or negedge rst_n)
   begin
      if (rst_n == 1'b0) begin
         signal_b_b1 <= # DLY 1'b0 ;
         signal_b_b2 <= # DLY 1'b0 ;
      end
      else begin
         signal_b_b1 <= # DLY signal_b ;
         signal_b_b2 <= # DLY signal_b_b1 ;
      end
   end

   always @ (posedge clka or negedge rst_n)
   begin
      if (rst_n == 1'b0) begin
         signal_b1_a1 <= # DLY 1'b0 ;
         signal_b1_a2 <= # DLY 1'b0 ;
      end
      else begin
         signal_b1_a1 <= # DLY signal_b_b1 ;
         signal_b1_a2 <= # DLY signal_b1_a1 ;
      end
   end

   assign puls_b_out = signal_b_b1 & (~signal_b_b2) ;
   assign levl_b_out = signal_b_b1 ;

endmodule
```

### 多bit信号的跨时钟电路

多bit信号的跨时钟电路一般有三种处理方式：DMUX\格雷码\异步fifo。

#### DMUX
 原理：将多Bit数据信号和单bit控制信号成对的从发送时钟域发往接受时钟域，控制信号在接收时钟域以两级同步器（打两拍）的形式接收，多Bit数据信号由同步后的单Bit控制信号控制的MUX决定数据是否通过。  
 
 ![p]()  

 
#### 格雷码  

关于格雷码，要记住的第一个事实是，任意两个相邻格雷码之间的距离只有1（相邻格雷码数值跳变时，只有一位可以改变）。要记住的第二个事实是，格雷码计数器都是2^n次幂的计数器。可以制作一个计算偶数个序列的灰码计数器，但对这些序列的转换通常不像标准的格雷码那么简单。还要注意，没有奇数长度的格雷码序列，所以人们不能制作一个23深度的格雷码。默认格雷码的深度都是2^ndeep。  

##### 二进制码转换成格雷码

法则是保留二进制码的最高位作为格雷码的最高位；次高位格雷码为二进制码的高位与次高位相异或，其余各位类似。  
 ![p]()   
 
```verilog
module bin_to_gray
#(parameter SIEZ = 4)
(
  input [SIZE - 1 : 0] bin,
  output [SIZE - 1 : 0] gray
);
  assign gray = (bin >> 1) ^ bin;    //0异或任何数等于其本身
 
endmodule
 ```  
 
##### 二进制格雷码转换成二进制码
法则是保留格雷码的最高位作为自然二进制码的最高位；次高位自然二进制码为高位自然二进制码与次高位格雷码相异或，其余各位类似。  
 ![p]() 
 
